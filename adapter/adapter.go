// Package adapter defines the interface that all data source adapters must implement.
// This allows the mapper to work with any data source (SQL, files, APIs, NoSQL) through
// a consistent interface.
package adapter

import "context"

// Adapter defines the interface all data source adapters must implement.
// Implementations handle the actual data operations for their specific data source.
type Adapter interface {
	// Fetch retrieves one or more objects based on operation and parameters.
	// Returns a slice of results that will be mapped to domain objects.
	Fetch(ctx context.Context, op *Operation, params map[string]interface{}) ([]interface{}, error)

	// Insert creates new objects in the data source.
	// Objects should be provided as a slice, even for single inserts.
	Insert(ctx context.Context, op *Operation, objects []interface{}) error

	// Update modifies existing objects in the data source.
	// Objects should include identifier fields for locating the records to update.
	Update(ctx context.Context, op *Operation, objects []interface{}) error

	// Delete removes objects from the data source.
	// Identifiers can be simple values (IDs) or complex objects with multiple fields.
	Delete(ctx context.Context, op *Operation, identifiers []interface{}) error

	// Execute runs custom actions like stored procedures or complex queries.
	// This provides an escape hatch for operations that don't fit the CRUD model.
	Execute(ctx context.Context, action *Action, params map[string]interface{}) (interface{}, error)

	// Connect establishes connection to the data source.
	// Config contains adapter-specific connection details.
	Connect(ctx context.Context, config map[string]interface{}) error

	// Close releases all resources (connections, file handles, etc.).
	Close() error

	// Name returns the adapter type name (e.g., "mysql", "filesystem", "redis").
	Name() string
}

// OperationType represents the type of database operation.
type OperationType string

const (
	// OpFetch retrieves data (SELECT in SQL, file read, API GET).
	OpFetch OperationType = "fetch"

	// OpInsert creates new data (INSERT in SQL, file write, API POST).
	OpInsert OperationType = "insert"

	// OpUpdate modifies existing data (UPDATE in SQL, file overwrite, API PUT).
	OpUpdate OperationType = "update"

	// OpDelete removes data (DELETE in SQL, file delete, API DELETE).
	OpDelete OperationType = "delete"

	// OpAction executes custom operations (stored procedures, complex queries).
	OpAction OperationType = "action"
)

// Operation represents a configured data operation.
// This is constructed from the YAML/JSON configuration and passed to adapters.
type Operation struct {
	// Type is the operation type (fetch, insert, update, delete).
	Type OperationType

	// Statement is the adapter-specific statement (SQL query, file path template, etc.).
	Statement string

	// Properties maps object fields to data fields for the operation.
	Properties []PropertyMapping

	// Identifier specifies which fields identify the object (for update/delete).
	Identifier []PropertyMapping

	// Generated specifies fields that are auto-generated (e.g., auto-increment IDs).
	Generated []PropertyMapping

	// Condition specifies conditional fields (e.g., optimistic locking version).
	Condition []PropertyMapping

	// Bulk indicates whether this is a bulk operation (multiple objects).
	Bulk bool

	// Multi indicates whether to return multiple results (for fetch).
	Multi bool

	// Source is the source name (used for CQRS pattern).
	Source string

	// Fallback is an alternative operation to try if this one fails (CQRS).
	Fallback *Operation

	// After contains actions to run after the operation (cache invalidation, etc.).
	After []AfterAction
}

// PropertyMapping maps an object property to a data field.
type PropertyMapping struct {
	// ObjectField is the name of the field in the Go struct.
	ObjectField string

	// DataField is the name of the field in the data source.
	DataField string

	// Type is an optional type conversion hint (timestamp, json, base64, etc.).
	Type string

	// Generated indicates whether this field is auto-generated by the data source.
	Generated bool
}

// Action represents a custom action (stored procedure, complex query, etc.).
type Action struct {
	// Name is the action identifier.
	Name string

	// Statement is the adapter-specific statement to execute.
	Statement string

	// Parameters maps input parameters.
	Parameters []PropertyMapping

	// Result defines how to map the action results (if any).
	Result *ResultMapping
}

// ResultMapping defines how to map results back to objects.
type ResultMapping struct {
	// Type is the Go type name to create.
	Type string

	// Multi indicates whether to return multiple results.
	Multi bool

	// Properties maps data fields back to object properties.
	Properties []PropertyMapping
}

// AfterAction represents an action to execute after an operation.
// This is used for cache invalidation, logging, event publishing, etc.
type AfterAction struct {
	// Type is the action type (invalidate, cache_set, publish, etc.).
	Type string

	// Source is the source to execute the action on.
	Source string

	// Statement is the adapter-specific statement for the action.
	Statement string

	// Config contains additional configuration for the action.
	Config map[string]interface{}
}

// Error types provide standardized error codes across all adapters.
var (
	// ErrNotFound indicates the requested object was not found.
	ErrNotFound = &AdapterError{Code: "NOT_FOUND", Message: "object not found"}

	// ErrValidation indicates a validation error (constraint violation, etc.).
	ErrValidation = &AdapterError{Code: "VALIDATION", Message: "validation failed"}

	// ErrConnection indicates a connection failure to the data source.
	ErrConnection = &AdapterError{Code: "CONNECTION", Message: "connection failed"}

	// ErrAdapter indicates a general adapter error.
	ErrAdapter = &AdapterError{Code: "ADAPTER", Message: "adapter error"}

	// ErrConfiguration indicates a configuration error.
	ErrConfiguration = &AdapterError{Code: "CONFIGURATION", Message: "configuration error"}

	// ErrConflict indicates a conflict (e.g., optimistic locking version mismatch).
	ErrConflict = &AdapterError{Code: "CONFLICT", Message: "conflict detected"}
)

// AdapterError represents an error from an adapter.
// It provides a structured error with code, message, and optional cause.
type AdapterError struct {
	// Code is a machine-readable error code.
	Code string

	// Message is a human-readable error message.
	Message string

	// Cause is the underlying error that caused this error (if any).
	Cause error
}

// Error implements the error interface.
func (e *AdapterError) Error() string {
	if e.Cause != nil {
		return e.Code + ": " + e.Message + ": " + e.Cause.Error()
	}
	return e.Code + ": " + e.Message
}

// Unwrap returns the underlying cause error.
// This allows errors.Is and errors.As to work correctly.
func (e *AdapterError) Unwrap() error {
	return e.Cause
}

// NewAdapterError creates a new AdapterError with a cause.
func NewAdapterError(code, message string, cause error) *AdapterError {
	return &AdapterError{
		Code:    code,
		Message: message,
		Cause:   cause,
	}
}
